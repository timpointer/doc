
# Consistency and Consensus

## Distribted Transactions and Consensus

### Fault-Tolerant Consensus

#### Single-leader replication and consensus
第五章讨论了单主副本的情况，所有写入都通过主节点，来确保从节点按照一致的顺序同步数据。这不就是total order broadcast吗？为什么我们之前不需要关心共识问题？

这个问题就回到主节点是怎么选出来的。如果主节点是手动选出来的，一旦主节点宕机，就需要重新手动选一个新的主节点。这种系统可以工作，但不满足共识的定义，需要人的干预系统才能有进展。

一些数据库实现了自动选主。fault-tolerant total order broadcast就是为了解决共识问题的。

因此，我们为了选主需要共识。但如果共识算法在这里的描述就是total order broadcast算法，同时算法有像单主副本，同时单主副本又需要选主，同时...

就像我们为了实现选主，首先需要一个主。为了解决共识问题，我们需要先解决共识问题。如何打破这种死循环呢？

#### Epoch numbering and quorums
// TODO

#### Limitations of consensus
共识算法是分布式系统的一个重大突破。为了一个到处充满不确定性的系统带来的安全特征，同时还保持fault-tolerant。他提供了total order broadcast。

为什么不能到处都用，因为好处是有代价的。

选举过程是一种同步备份。我们讨论的大多数数据库都是异步备份。这种配置下，failover会导致到数据丢失，但人们为了性能接受了这一点。

共识系统需要严格的多数才可用。三个节点允许宕机一个节点，五个节点允许宕机两个节点。如果网络中断，只有多数部分的节点可以服务，其余的都中断服务。

大多数共识算法假定固定投票节点数量。Dynamic membership的算法也有，但过于复杂不推荐。

共识算法依赖于timout发现宕机节点。在高网络延迟的环境，会导致频繁选举，使得系统性能骤降。

### Membership and Coordination Services

Zookeeper或Etcd总被描述为 分布式KV存储或协调配置服务。它们的API很想数据库。如果它们只是普通的数据库，为什么要花力气去实现共识算法呢？是什么使他们有别与其他数据库的？

为了明白这一点，我们先看看zookeeper的一般使用场景。通常作为应用开发很少直接使用zookeeper，而你用的服务，它们大多数会在背后依赖zookeeper，比如kafka。
那么它们能从zookeeper这里得到什么好处呢？

Zookeeper被设计用来存储少量数据，能整个放进内存，所以你会拿它来存应用数据。少量数据的分发到所有节点使用fault-tolerant total order broadcast algorithm。就像前面讨论的total order broadcast正式数据库副本同步数据所需要的。

Zookeeper不仅仅实现了total order broadcast。也提供其他一些在分布式系统中特别有用的一些有趣特性：
- 线性原子操作
- 操作的完全顺序
- 节点故障发现
- 变更通知

以上这些特性，只有线性原子操作真正用到了共识算法。然而，这些特性的组合使得zookeeper对分布式协调来说很有价值。

#### Allcating work to nodes
Zookeeper的一个例子是，如果你有几个服务实例，需要在它们中间选择一个leader。如果leader宕机了需要其他节点替代它的位置。这就是单主数据库，和任务调度系统的场景。

另一个例子是集群有新节点加入，需要重新分配分片给不同的节点。

这些类似的任务通过Zookeeper提供的功能比如：原子操作，节点监控，通知可以达成。如果实现正确，就可以在无需人工干预的情况下系统自动恢复。
即使借助Apache Curator客户端来实现也并不是那么简单，但比起自己实现共识算法还是要容易许多。

一个应用可能一开始是单节点，但最终增长为几千个节点。尝试在这么多节点中投票是很没有效率的。另一种方法是，zookeeper只在固定的节点运行同时支持大量客户端。
因此，zookeeper为协调节点工作提供一种外包给外部服务的方法。

通常，zookeeper 管理的数据变更很缓慢，比如"10.1.1.23节点现在是分片7的leader“，通常变更频率在几个小时。

#### Service discovery
在云环境中，服务器的IP通常是不断变化的。客户端需要询问服务注册系统拿到服务对应的IP。

然而服务发现是否真的需要共识算法呢？DNS是传统的查询一个通过服务名查找IP的方式。通常有多级缓存，读也不是线性的，并且拿到旧数据也通常不认为有什么问题。
对DNS来说可靠性和网络健壮性才是最重要的。

虽然服务发现不需要共识算法。然后如果你的共识系统已经知道谁是leader,然后这个leader就可以帮助其他服务发现谁是leader。所以一些共识系统支持只读副本。
这些副本异步同步共识算法所有决定的日志，但不参与投票。因此他们能支持不需要线性一致的读请求。

#### Membership services

# 总结
我们从不同的角度观察了一致性和共识这个主题。在深度探讨了线性linearizability，一个最流行的一致性模型：它的目标是让副本数据看上去像只有一份数据一样，所有操作都是原子的。虽然这样容易理解，就好像数据库的表现像在单线程应用里面一样，但不好的地方是慢，特别在网络延迟大的环境。

我们也探讨了因果性，一个系统中事件有顺序。不像线性，所有操作都是完全顺序，因果性提供了较弱的一致性模型。一些事能并发，所以版本的历史像一个时间线不断分支合并。因果一致性没有线性的协调负担同时对网络问题没那么敏感。

然后如果我们只抓住因果顺序，我们是不能实现用户名唯一性限制的。如果一个节点接受注册，它需要知道其他节点没有并发注册相同的用户名。这个问题将我们引向了共识问题。

我们看到达成共识意味着所有节点都认同某给决定，并且决定不可逆。深挖一下，我们发现很多问题和共识是等价的。
- 原子compare-and-set
- 原子事务提交
- 完全顺序广播
- 锁和租约
- 组员协调服务
- 唯一性限制

所有这些都很直观，如果你仅有一个节点或你人工指定某一个节点有决策权。这发生在单主数据库中，所有权利都在主节点上，这样才能提供线性操作，唯一性限制，和完全顺序同步日志，等等

然而，如果主节点宕机，或网络中断导致主节点无法访问，那么这个系统就变得不可用。有三种方法来解决这个问题：
1. 等待主节点恢复，如果主节点不恢复，系统将永远不可用。
2. 手动重新选主，从新配置系统。需要关系型数据库就是这么做的。这是一种”上帝“共识，管理员就是上帝，在计算机系统之外，来做这个决定。恢复速度取决于人的响应速度，通常比计算机慢。
3. 使用算法自动选主。这个方法需要共识算法，采用一个已被证明是可靠的共识算法。

虽然单主数据库在没有对每个写操作执行公式算法的情况下，提供了线性一致性，但它自身仍然需要共识来选主。公式算法仍然是需要的，只是在不同的地方，频率很少而已。好消息是，我们已经有了共识算法和提供这种算法的系统。

Zookeeper就提供这样一种能力，虽然使用上不算很简单。但比起自己实现算法还是要好的多。

然而，不是所有系统都需要共识：比如，无主和多主副本系统通常没有全局共识。这些系统会发生冲突，这是多主而没有共识的结果，但可接受：可能我们可以接受没有线性一致性，并学习更好的应对数据的多分支与合并历史的情况。

我们参考了大量分布式系统理论研究的结果，虽然论文和证明不是很容易理解，有时做了一些不真实的假设，但它们是非常有价值的。帮助我们认清什么是可能的，什么是不可能的，帮助我们找到在分布式系统中一些反直觉的问题。







