
# 多主副本
通常我们都采用单主副本的方式，但也有其他有趣的替代方案。
单主副本一个主要缺点是仅有一个主节点，所有写入都要通过它。如果因为任何原因你不能连接主节点，你就不能写入数据。

一个自然的扩展就是允许多个主节点。每个节点都能处理写操作并把数据传输给其他节点。每个主节点就扮演其他主节点的从节点。

## 多主场景

很少会在一个数据中心采用多主副本，因为增加了复杂度但没带来多少好处。然而有些场景是合理的。

### 多数据中心

想象都多个数据中心，每个中心内部采用一般的单主副本，然后两个中心之间，主节点互为主从。当一个数据中心宕机后，另一个数据中心能继续接受请求。
比较一下单主和多主的区别：
- 性能，主节点更贴近用户，所以性能更好。
- 忍受数据中心宕机，单主情况下，如果主节点宕机，需要失败恢复。在多主情况下，每个数据中心独立运行，故障的数据中心恢复后，通过副本追赶上即可。
- 忍受网络问题，两个数据中心之间通常走公网。网络不稳定，多主采用异步传输，暂时的网络中断不会有什么影响。

一些数据默认支持多主，但也有一些需要依赖额外工具，比如MySQL.
虽然多主有好处，但也有一个大问题：一些数据并发在两个数据中心被修改，这些写入冲突需要被解决。

多主在许多数据中是比较新的特性，通常于其他特性不兼容，基于这个原因，应该尽可能避免踏足这个危险的领域。

### 离线应用
如果你的应用可以离线操作。
比如你手里里面有个日历应用，你可以在离线时预定会议。等在线后，数据会被同步到远端的数据中心。
这种场景，可以认为每个应用都一个小的数据中心。然后异步传输数据到另一个数据中心，数据延迟可能在几个小时以上。

从架构的角度来看，就是一个多主架构。多主数据同步是一件很困难的事。
有些工具专门为了解决这类难题，比如CouchDB。

### 协作编辑

实时在线编辑应用，允许多人同时在线编辑一个文档。比如Google Docs。

我们通常不认协作编辑是一个数据同步问题，但有许多相似之处。当一个用户编辑一个文档，变更发生在本地，然后异步传输到服务器，同时其他人也在做同样的事。

如果你想保证，没有任何编辑冲突，应用必须在一个用户修改之间获取一个锁。如果另一个用户也想编辑同一个文档，他们必须等待第一个人提交后才行。这种协作就等同于单主副本加上事务。

然后，为了更快的协作，可能每次变更都很小，并且避免锁。这种方式允许多用户同时编辑，但也会带来所有多主副本的问题，包括需要处理冲突。

## 处理冲突

多主的最大问题就是写冲突会发生，所有解决冲突是必须的。

举例，一个文档同时被两个用户修改，用户1把标题从A改为C,用户2把标题从A改为B。每个用户都修改成功了，然后当改变是异步传输，一个冲突被发现了。这种问题不会在单主副本中发生。

### 同步对异步冲突的发现

在单主数据库中，第二个写入要么被堵塞并等待第一个完成，或是中断，然后重试。另一方面，在多主副本中，两个写入都成功，冲突只在稍后异步传输时被发现。此时，让用户来解决这个问题。

理论上，你可以同步发现冲突，等待写入传输到所有副本后才告诉用户写入成功。然而，这些就丢失所有多主的好处（允许每个副本独立处理写操作）。如果你想同步发现冲突，就用单主副本。

### 避免冲突

最简单的策略就是避免冲突：如果所有对于一条特定的数据都通过同一个主节点，那样就不会有冲突发生。因为多主副本冲突处理的不好，避免冲突是最推荐的方法。

比如一个应用用户能修改自己的数据，你能确保一个特定的用户就路由到指定的数据库，使用那个数据中心的主节点处理读写请求。不同用户都有不同的数据中心作为“家”，这样从一个用户的角度来看就是单主架构。

然后，有时候你可能希望改变被指定的主节点。可能应为数据中心宕机或用户移动到其他地点。这种情况时，避免冲突前提被打破，你还是不得不处理冲突。

### 汇聚到一致状态

单主数据库是按照一个顺序执行写入的：如果对于一个字段有几次更新，那么以最后一次写入为准。

在多主的情况下，并没有任何被定义的写入顺序，所以不清楚最终值是什么。

如果每个副本都按照它们自己接受的写入操作执行，最终数据会陷入一个不一致的状态。这是不可接受的，每个副本都必须确保数据最终在所有副本中是同一个值。数据库必须以汇聚的方式来解决冲突，意味着当数据被传输到所有副本时，必须是同一个最终值。

有不同的方式来解决冲突：
- 给每个写入一个唯一ID，比如时间戳，把ID最高的写入作为胜利者，丢弃其他写操作的值。如果使用时间戳，这种技术就被称为last write wins (LWW)。虽然这种方式很流行，但会有数据丢失的风险。
- 给每个副本一个唯一ID，让ID最大的那个副本来决定最终值。也会有数据丢失的风险。
- 把所有值合并起来，比如 B和C 合并为 B/C
- 用一个明确的数据结构记录下冲突相关的信息，保留下来等待后续处理，比如展示给最终用户看，让用户来决定（比如Git）

### 自定义冲突解决逻辑

最合适的方式是依赖应用来解决冲突，大多数多主的数据库允许用户使用应用代码写一些处理冲突的逻辑。这些代码可能在写或读的时候执行。

- 在写时
一旦数据库发现传输数据有变更冲突，就调用冲突处理器。执行用户预先定义的处理逻辑。

- 在读时
在冲突被发生时，所有冲突的写都被存储下来。下次数据被读取时，多个版本的数据会返回给用户。应用可能展示给用户或自动处理冲突，再把结果写会数据库。

注意冲突解决通常应用在单条记录或文档级别，而不是整个事务。因此，如果你有一个事务中执行了多个写操作，每个写操作被单独分开来解决冲突。

### 什么是冲突
一些冲突很明显，比如两个写操作更新同一个字段的值。但其他一些更加微妙。
比如一个预定会议室的应用。跟踪会议室被哪个人预定，如果两个人，在同一时间预定了同一个会议室。 在多主情况下就会发生，这就可能导致冲突。

### 多主拓扑结构

有环状，星状，和全对全

环状，星状每条记录都需要经过所有节点才复制完毕。

但全对全也有问题。同时并发写会出现，因果问题。



