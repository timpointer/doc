# Locks
28.1 最基本的锁
```
lock_t mutex 
lock(&mutex)
balance = balance + 1
unlock(&mutex)
```
锁只是一个变量，使用之前你必须先声明它，锁有两种状态，可得的（unlocked或者free)，或不可得的(lock或held)。我们能在锁里保存一些信息，比如当前哪个线程占有了锁，或等待要获取锁的线程队列，但这些信息对用户不可见。
当一个线程获取了锁，它就是这个锁的所有者。只有它能进入关键区，其他人只能等待。等所有者释放了锁，其他等待的人会获取到通知，锁已经空出，然后下一个人获取锁后，进去关键区。
锁提供给了程序员最小的调度控制权。通常线程是被程序创建出来的实例，由操作系统控制。锁又让程序员拿回了一些控制权，通过在关键区周围放置锁，能避免一个以上的线程进去关键区。锁让混乱的系统调度回归了一点点控制。

28.2 线程锁
POSIX库提供的锁是mutex。
锁分为粗粒度和细粒度，细粒度的锁能让更多线程同时进入关键区。

28.3　构建锁
现在，我们已经从程序员的角度明白了锁是怎么工作的。但要如何构建一个锁呢？需要什么样的硬件支持？哪些系统支持？
－　如果构建一个锁
我们要如何构建一个有效的锁？有效的锁以低成本提供互斥功能，也有其他一些将要讨论的特性。

要让锁能起作用，需要我们老朋友，硬件和系统的帮忙。多年来已经有一些不同的硬件原语被加入到指令集。我们将使用它们构建一个成熟的锁库。

28.4