# Locks
28.1 最基本的锁
```
lock_t mutex 
lock(&mutex)
balance = balance + 1
unlock(&mutex)
```
锁只是一个变量，使用之前你必须先声明它，锁有两种状态，可得的（unlocked或者free)，或不可得的(lock或held)。我们能在锁里保存一些信息，比如当前哪个线程占有了锁，或等待要获取锁的线程队列，但这些信息对用户不可见。
当一个线程获取了锁，它就是这个锁的所有者。只有它能进入关键区，其他人只能等待。等所有者释放了锁，其他等待的人会获取到通知，锁已经空出，然后下一个人获取锁后，进去关键区。
锁提供给了程序员最小的调度控制权。通常线程是被程序创建出来的实例，由操作系统控制。锁又让程序员拿回了一些控制权，通过在关键区周围放置锁，能避免一个以上的线程进去关键区。锁让混乱的系统调度回归了一点点控制。

28.2 线程锁
POSIX库提供的锁是mutex。
锁分为粗粒度和细粒度，细粒度的锁能让更多线程同时进入关键区。

28.3　构建锁
现在，我们已经从程序员的角度明白了锁是怎么工作的。但要如何构建一个锁呢？需要什么样的硬件支持？哪些系统支持？
－　如果构建一个锁
我们要如何构建一个有效的锁？有效的锁以低成本提供互斥功能，也有其他一些将要讨论的特性。

要让锁能起作用，需要我们老朋友，硬件和系统的帮忙。多年来已经有一些不同的硬件原语被加入到指令集。我们将使用它们构建一个成熟的锁库。

28.4 评估锁
在构建锁之前，要先明白我们的目标，如何评估一个锁实现的有效性。我们应该建立一些准则。
1. 互斥功能，防止多个线程进入关键区
2. 公平性，确保每个线程都有相同的机会获取到锁，避免出现饥饿
3. 性能，不同常见下的表现。没有竞争的时候，有竞争的时候，多CPU的情况下。比较不同的常见，让我们能更好的明白不同锁技术对性能的影响。

28.5　控制打断
最简单实现锁的方式
```
lock() {
DisableInterrupts()
}
unlock() {
EnableInterrupts()
}
```
